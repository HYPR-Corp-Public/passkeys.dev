var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/intro/",title:"Intro",description:"Prologue Doks.",content:""}),e.add({id:1,href:"/docs/intro/what-are-passkeys/",title:"What are passkeys?",description:"Passkeys are a replacement for passwords. A password is something that can be remembered and typed, and a passkey is a secret stored on one’s devices, unlocked with biometrics.",content:`Passkeys solve every single one of the problems described above.
Intuitive: creating and using passkeys is as simple as consenting to save and use them. No having to create a password. Automatically unique per-service: By design, passkeys are unique per-service. There’s no chance to reuse them. Breach-resistant: A passkey is only stored on a user’s devices. RP servers store public keys. Even servers that assist in the syncing of passkeys across a user’s devices never have the ability to view or use the user\u0026rsquo;s WebAuthn private keys. Phishing-resistant: Rather than trust being rooted in a human who has to verify they’re signing into the right website or app, browser, and operating systems enforce that passkeys are only ever used for the appropriate service. Passkeys are FIDO credentials, usable in web browsers through the WebAuthn API, and usable in apps through OS-specific APIs that closely resemble WebAuthn.
`}),e.add({id:2,href:"/docs/use-cases/",title:"Use Cases",description:"Implement passkeys",content:""}),e.add({id:3,href:"/docs/use-cases/bootstrapping/",title:"Bootstrapping",description:"Bootstrapping an account on the web",content:`Authenticating the user #This section applies when the relying party does not yet know who is controlling the client device. There is no browser artifact (such as a cookie or a credential ID in local storage) available to the relying party, although for now we assume that the user has an existing account with the relying party.
To bootstrap an account, serve the user a sign-in page.
Start off by asking the user for their account identifier, typically a username or email address:
To support the autofill UI for passkeys, make sure to:
Add the username and webauthn value to any existing autocomplete annotations on the username input field as shown below in the example.
\u0026lt;div\u0026gt; \u0026lt;label for=\u0026quot;username\u0026quot;\u0026gt;Username:\u0026lt;/label\u0026gt; \u0026lt;input name=\u0026quot;username\u0026quot; id=\u0026quot;loginform.username\u0026quot; autocomplete=\u0026quot;username webauthn\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; On page load, check to see if conditional mediation (autofill UI) is supported using an if statement, then call navigator.credentials.get() with mediation: \u0026quot;conditional\u0026quot; and userVerification: \u0026quot;required\u0026quot;.
if (navigator.credentials.conditionalMediationSupported) { navigator.credentials.get({ mediation: \u0026quot;conditional\u0026quot;, publicKey: { challenge: ..., // server generated challenge value rpId: ..., // RP's domain name userVerification: \u0026quot;required\u0026quot;, } }); } This will cause the following to happen:
When the user interacts with the username field, the browser and platform will check whether a passkey exists in the platform authenticator that can be used with the relying party. If this is the case, the passkey will be presented to the user as an option to choose (along with other credentials that can be auto-filled, such as usernames stored in the browser’s password manager). The browser/platform might render a UI similar to the one shown below, although the exact look and feel will vary from platform to platform (Windows vs. Android vs. iOS), and from form factor to form factor (desktop vs. mobile): If the user selects the passkey, the platform UI will guide the user through a (often biometrics-based) user verification check.
If the user successfully passes the user verification, the navigator.credentials.get() succeeds and returns a WebAuthn response.
If the user selects a credential other than a passkey, the browser/platform chooses a different appropriate action (such as auto-filling the username), and the navigator.credentials.get() call does not resolve.
If the user selects the \u0026ldquo;Passkey from another device\u0026rdquo; option (NOTE: the exact text will vary slightly by platform), then the browser/platform will guide the user through using a FIDO2 security key or the Cross-Device Authentication (CDA) flow to use a passkey from their smartphone or tablet to deliver a WebAuthn response to the navigator.credentials.get() call.
This is why this is called the Conditional UI (often called the Autofill UI) mode of WebAuthn — the platform authenticator UI that guides the user through the verification, or through using their phone, is only shown if the user has a passkey on this device (or chooses the \u0026ldquo;another device\u0026rdquo; option).
As we can see, in this mode the navigator.credentials.get() call either succeeds, or it doesn’t (never resolves). If it does succeed, then the result of the call will reveal both a user id, as well as a signed WebAuthn assertion, which the relying party will use to authenticate the user.
If the call doesn’t succeed, perform a \u0026ldquo;legacy\u0026rdquo; user authentication: you’ll get a username from this first page, and you then serve appropriate further login challenges (such as passwords, responding to SMS challenges, etc.) to the user in subsequent pages. These may include \u0026ldquo;account recovery\u0026rdquo; steps in case the user has forgotten their password or is otherwise not able to pass the regular login challenges. Once the user has passed all the login challenges, they’re considered authenticated and signed in.
What happens when the user doesn’t already have an account with the relying party? Usually, you will give users the option on the sign-in page to create an account. If the user chooses that option, collect the necessary information from the user to open a new account. If the user successfully opens a new account, they’re also considered authenticated and signed-in.
Once the user is signed in, it might be time to set up a new passkey for them. Do this for any of the following cases:
The user bootstrapped their account on the device by passing non-passkey login challenges (such as using a password). The user just created a new account at the relying party, and is considered signed-in because of that. The user was using a passkey, but they used a different device than the one they’re currently on (by selecting the \u0026ldquo;other device\u0026rdquo; shown in the example above). This can be checked by inspecting the authenticatorAttachment attribute in the returned PublicKeyCredential object. Setting up a new passkey for these cases is in the next session.
Opting the user into passkeys #First check whether the two calls below return true.
PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable() navigator.credentials.conditionalMediationSupported If they are, then the user\u0026rsquo;s system features a FIDO platform authenticator that supports conditional UI mode, and you can offer the user the convenience and security of using passkeys.
Serve an opt-in or \u0026ldquo;upsell\u0026rdquo; modal/interstitial or page to the user offering them to create a passkey:
If the user has signed in with a passkey from a another device (such as a phone, tablet, or FIDO2 security key), you might adjust the wording accordingly:
Consider showing (or linking to) longer descriptions explaining that all users that are able to unlock the current device will be able to access the account at the relying party to ensure that the user is giving fully informed consent.
If the user consents, call navigator.credentials.create(), making sure to ask for a platform authenticator, user verification, discoverable credentials (aka \u0026ldquo;resident keys\u0026rdquo;), and passing an exclude list of existing passkeys for the account:
navigator.credentials.create({ publicKey: { rp: { ...}, user: { ...}, challenge: ..., pubKeyCredParams: [ { \u0026quot;type\u0026quot;: \u0026quot;public-key\u0026quot;, \u0026quot;alg\u0026quot;: -7 // EC P256 }, { \u0026quot;type\u0026quot;: \u0026quot;public-key\u0026quot;, \u0026quot;alg\u0026quot;: -257 // RSA } ], excludeCredentials: [ { // other passkeys (i.e., credentials) tied to the user account type: \u0026quot;public-key\u0026quot;, id: new UInt8Array([21, 31, 56, ...]).buffer, }, { type: \u0026quot;public-key\u0026quot;, id: new UInt8Array([21, 31, 56, ...]).buffer, }, { ... } ], authenticatorSelection: { authenticatorAttachment: \u0026quot;platform\u0026quot;, residentKey: \u0026quot;required\u0026quot;, userVerification: \u0026quot;required\u0026quot; }, } }) A note on attestation: We recommend that most relying parties not specify the attestation conveyance parameter attestation (thus defaulting to none), or instead explicitly use the value indirect. This guarantees the most streamlined user experience (platforms are likely to obtain consent from the user for other types of attestation conveyances, which likely results in a larger fraction of unsuccessful credential creations due to users canceling the creation).
When the WebAuthn call resolves, send the response to your server and associate the returned public key and credential ID with the user account.
`}),e.add({id:4,href:"/docs/tools-libraries/",title:"Tools \u0026 Libraries",description:"Prologue Doks.",content:""}),e.add({id:5,href:"/docs/tools-libraries/libraries/",title:"Libraries",description:`Recommended #Simple WebAuthn `,content:`Recommended #Simple WebAuthn `}),e.add({id:6,href:"/docs/tools-libraries/test-sites/",title:"Test Sites",description:"",content:""}),e.add({id:7,href:"/docs/reference/",title:"Reference",description:"Help Doks.",content:""}),e.add({id:8,href:"/docs/reference/android/",title:"Android",description:"Resources for passkeys in Android",content:` Local Authenticator (create and use passkeys from the local device)
Planned External Authenticator (create and use passkeys from another device)
Planned Overview #Passkeys are not currently supported in Android but are coming soon!
Platform Notes #Coming Soon
Resources #FIDO2 API for Android Sample app `}),e.add({id:9,href:"/docs/reference/chromeos/",title:"Chrome OS",description:"Resources for passkeys in Google's Chrome OS",content:` Local Authenticator (create and use passkeys from the local device)
Planned External Authenticator (create and use passkeys from another device)
Supported `}),e.add({id:10,href:"/docs/reference/ios/",title:"iOS \u0026 iPadOS",description:"Resources for passkeys in Apple's iOS and iPadOS",content:` Local Authenticator (create and use passkeys from the local device)
Supported External Authenticator (create and use passkeys from another device)
Supported Overview #The platform authenticators in iOS 16+ and iPadOS 16+ have the following capabilities:
creating and using passkeys that are backed up to iCloud Keychain creating and using passkeys on/from another device, such as: an iPhone or iPad signed in to a different iCloud account a FIDO2 security key Platform Notes #WebAuthn credentials created using the platform authenticator in iOS/iPadOS 15 and earlier will not not be converted to passkeys but will remain available for the lifetime of the device.
To replace a legacy platform credential with a passkey, start a credential registration ceremony and pass the same user handle (user.id) in the request. iOS/iPadOS will overwrite the legacy credential with a new passkey that will be backed up to iCloud Keychain.
Resources #Apple landing page for passkeys Supporting passkeys Supporting single-device passkeys on security keys Sample Code `}),e.add({id:11,href:"/docs/reference/macos/",title:"macOS",description:"Resources for passkeys in Apple macOS",content:` Local Authenticator (create and use passkeys from the local device)
Supported External Authenticator (create and use passkeys from another device)
Supported Overview #The platform authenticator in macOS Ventura (13) has the following capabilities:
creating and using passkeys that are backed up to iCloud Keychain creating and using passkeys on/from another device, such as: an iPhone or iPad signed in to a different iCloud account a FIDO2 security key Platform Notes #Legacy Credentials #WebAuthn credentials created using the platform authenticator in macOS Monterey (12) and earlier will not not be converted to passkeys but will remain available for the lifetime of the device.
To replace a legacy platform credential with a passkey, start a credential registration ceremony and pass the same user handle (user.id) in the request. macOS will overwrite the legacy credential with a new passkey that will be backed up to iCloud Keychain.
Browser Behavior #Safari: credentials created in Safari are passkeys, are backed up to iCloud Keychain, and are available in other apps and services.
Chrome: credentials created by Chrome are currently single-device passkeys, are not backed up to iCloud Keychain, and are not available outside of Chrome.
Edge: credentials created by Edge are currently single-device passkeys, are not backed up to iCloud Keychain, and are not available outside of Edge.
Firefox: passkeys are not currently supported in Firefox on macOS. Single-device passkeys on a FIDO2 security key are supported.
Resources #Apple landing page for passkeys Supporting passkeys Supporting single-device passkeys on security keys Sample Code `}),e.add({id:12,href:"/docs/reference/windows/",title:"Windows",description:"Resources for passkeys in Microsoft Windows",content:` Local Authenticator (create and use passkeys from the local device)
Planned External Authenticator (create and use passkeys from another device)
Partially Supported Overview #Windows Hello, the platform authenticator in Windows 10 and 11, has the following capabilities:
creating and using single-device passkeys that are bound to the device creating and using single-device passkeys on a FIDO2 security key Passkeys from iOS, and iPadOS can be used in Chrome (105+) and Edge (105+) for signing in to web services using FIDO Cross-Device Authentication.
Platform Notes #Coming Soon
Resources #Coming Soon
`}),e.add({id:13,href:"/docs/reference/terms/",title:"Terms",description:"Regularly update the installed npm packages to keep your Doks website stable, usable, and secure.",content:`2FA user #a user whose account has 2FA turned on, i.e., who must present 2 authentication factors during sign-in.
2-Factor Authentication (2FA) #also sometimes referred to as MFA: multi-factor authentication or 2SV: two-step verification
This refers to a contract between a user and a relying party where the relying party must collect at least two distinct authentication factors from the user during a bootstrap sign-in.
Account boostrapping #A relying party authenticates a user without any prior knowledge of who the user is. This means that the relying party not only has to verify the identity of the user (checking the password, verifying cryptographic signatures, etc), it also has to establish the identity of the user (figure out the user id, username, etc. of the user who’s signing in). This may happen when a user signs into an existing account for the first time on a newly-purchased phone. Or when a user logs into a website for the first time in a given browser instance. Or when a user logs into a website in a private browsing session. Or when a user signs into a mobile app for the first time on a given device. (Contrast this with reauthentication below.) Note that this is different from creating an account with a service in the first place.
Authentication factor #Information provided by a user (or one of the user’s devices) for purposes of authentication, usually in response to a login challenge. Often categorized into \u0026ldquo;knowledge factors\u0026rdquo; (e.g. passwords), \u0026ldquo;something you have\u0026rdquo; factors (e.g. another already signed-in device), and \u0026ldquo;something you are\u0026rdquo; factors (e.g. biometrics). Note that a single login challenge may collect multiple factors simultaneously.
Login challenge #A prompt served to the user that they need to pass. For example, a prompt asking the user for their password is a login challenge. A prompt asking the user to confirm sign-in on another device (e.g., their phone) is a login challenge. A prompt asking the user to insert and activate their security key is a login challenge. Account bootstrapping and reauthentication usually consist of serving the user one or more login challenges.
Logging in #see Signing in.
Passkey #sometimes referred to as a multi-device passkey
A WebAuthn credential that can reliably be used for bootstrap sign-in, without requiring other login challenges such as passwords. “Reliable” here means that the passkey should be available to, and usable by, the user whenever they need to sign in. This availability can be achieved through different means: for example, platforms could restore passkey credentials from a backup whenever a user sets up a new device, offer passkeys across different contexts (a passkey established from an app can be used in the browser when visiting the app’s website), or allow users to exercise passkeys across devices (by, say, using the passkey credential on a nearby phone when signing in from a laptop). The important thing is that a passkey is there when the user needs it, and that it can be used without other additional login challenges. A webauthn credential that was created in a private browsing context and disappears when that browsing context is dismissed would not be considered a passkey (since it won’t be there for the user next time they’re trying to sign in). Nor would a U2F credential on a physical Security Key (since it requires additional factors for sign-in).
Platform authenticator #A FIDO authenticator that is built-in to a user\u0026rsquo;s device.
Reauthentication #Reauthentication happens when a relying party already knows who the user is, but would like to reconfirm this. For example, this happens before making sensitive changes to an account (add a recovery email address, change the passwords, etc.): a relying party would typically ask the user to re-enter their password or perform some other action to reconfirm their control of the session. Likewise, when a mobile app asks the user to sign in every time the app starts (or a web site asks the user to sign in again after a period of inactivity), this is technically a reauthentication, since the app or web site can choose to remember the user\u0026rsquo;s identity after the account has been bootstrapped on the device, e.g., by setting cookies.
Relying Party (RP) #The website that is trying to ascertain and verify the identity of the user or perform FIDO authentication.
Roaming authenticator #A FIDO authenticator usable with any device the user is trying to sign-in from. Roaming authenticators attach to users\u0026rsquo; devices in varying fashions. For example: via USB, NFC, or Bluetooth. These authenticators are often referred to as \u0026ldquo;security keys\u0026rdquo;. A smartphone can also act as a roaming authenticator.
Signing in #This can refer to either account bootstrapping or reauthentication. When in doubt, we will use the latter, more descriptive, terms in the sections below.
Single-device passkey #User-Verifying Roaming Authenticator (UVRA) #UVRAs can verify individual users through the use of biometrics, or through the user typing a PIN or password, etc. An important class of UVRAs are smartphones, in which case the “attachment” typically happens over a wireless connection.
`}),e.add({id:14,href:"/docs/reference/specs/",title:"Specifications",description:"List of specifications that enable passkeys",content:`The two primary technical specifications that work together to enable passkeys are Web Authentication, commonly referred to as WebAuthn, and the Client to Authenticator Protocol (CTAP), commonly referred to as FIDO2.
The two specs together are often referred to as one stack, FIDO2/WebAuthn.
W3C Web Authentication (WebAuthn) #WebAuthn is the primary specification used by developers.
Platforms also create their own platform-specific abstractions of the WebAuthn API for use by native apps.
Current Version: WebAuthn Level 2
Next Version: WebAuthn Level 3
Client to Authenticator Protocol (CTAP) #The FIDO Client to Authenticator Protocol, often referred to by its acronym CTAP, is responsible for communications with the authenticator over a number of transports including USB, NFC, and Bluetooth. Operating systems, and in some cases apps, utilize this protocol to pass requests from WebAuthn to the appropriate authenticator over its desired transport.
CTAP is implemented by authenticator and device vendors and abstracts away all of the complexity of interacting with authenticators from relying parties and developers.
Current Version: CTAP 2.1
Next Version: CTAP 2.2
The next version of CTAP is currently under development at the FIDO Alliance.
In the context of passkeys, CTAP 2.2 adds support for the hybrid transport, more commonly known as the FIDO Cross-Device Authentication flow, allowing a passkey to be used to sign in on another device (ex: passkey on Android signing into a service on Windows).
`}),e.add({id:15,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()